/*
* EZ-Modules: A collection of helpful modules for the EZ programming language
* Be aware these modules may one day be added into the EZ language stdlib and thus would be superseded by the stdlib version
*
* Module Name: heap
* Module Desc: A min-heap (priority queue) implementation. Always returns the lowest priority item first.
* All functions and constants are prefixed with 'heap'
*
* File Name: heap.ez
* File Desc: Core heap data structure with push, pop, peek operations
*
* Author: Marshall A Burns
* GitHub: @SchoolyB
* Repo: https://github.com/SchoolyB/EZ-Modules
*
* Copyright (c) 2026 Marshall Burns
* Licensed under the MIT License
*/
module heap
import @arrays, @std

temp Heap [HeapItem]

const HeapItem struct {
	priority int
	value Variant
}

const Variant struct {
	stringValue string
	intValue int
	floatValue float
	boolValue bool
	type [int]
}

//===============================
// INTERNAL USE ONLY FUCNTIONS
//===============================
// private do make_string_variant(s string) -> Variant {
//      temp G = new(Variant)
//      G.stringValue = s
//      // G.intValue = 0
//      // G.floatValue = 0.0
//      // G.boolValue = false
//      G.type = {1, 0, 0, 0}
//      return G
//  }


 private do heap_make_variant(strVal string = "",intVal int = 0,floatVal float = 0.0,boolVal bool = false)-> Variant{
 	temp G = new(Variant)

   	G.stringValue = strVal
  	G.intValue = intVal
   	G.floatValue = floatVal
    G.boolValue = boolVal
    // G.type = {1, 0, 0, 0}

    return G
 }

 // Create a Variant containing an int
 // private do make_int_variant(index int) -> Variant {
 //     temp G = new(Variant)
 //     // G.stringValue = ""
 //     G.intValue = index
 //     // G.floatValue = 0.0
 //     // G.boolValue = false
 //     G.type = {0, 1, 0, 0}
 //     return G
 // }

 // Create a Variant containing a float
 // private do make_float_variant(f float) -> Variant {
 //     temp G = new(Variant)
 //     // G.stringValue = ""
 //     // G.intValue = 0
 //     G.floatValue = f
 //     // G.boolValue = false
 //     G.type = {0, 0, 1, 0}
 //     return G
 // }

 // Create a Variant containing a bool
 // private do make_bool_variant(b bool) -> Variant {
 //     temp V = new(Variant)
 //     // G.stringValue = ""
 //     // G.intValue = 0
 //     // G.floatValue = 0.0
 //     G.boolValue = b
 //     G.type = {0, 0, 0, 1}
 //     return G
 // }

//Creates a new HeapItem with passed in priority(p) and Variant(v)
private do make_new_heap_item(p int, v Variant) -> HeapItem {
	temp item = new(HeapItem)

	item.priority = p
	item.value = v
	return copy(item)
}

// Gets the parent index of a node at passed in index
private do heap_parent_index(index int) -> int {
    return (index - 1) / 2
}

//Get the left child index of a node at index i
private do heap_left_child_index(index int) -> int {
    return (2 * index) + 1
}

// Gets the right child index of a node at index i
private do heap_right_child_index(index int) -> int {
    return (2 * index) + 2
}

// NOTE: Bubble up and down functions are all Claude Code... Not ashamed to say it - Marshall

// BUBBLE UP: After inserting at the end of the heap, move the item UP until heap property is restored
//
// Example: Insert priority 1 into heap [2, 5, 3]
//   Step 1: Add to end -> [2, 5, 3, 1]
//   Step 2: Compare 1 with parent (5 at index 1): 1 < 5, so swap -> [2, 1, 3, 5]
//   Step 3: Compare 1 with parent (2 at index 0): 1 < 2, so swap -> [1, 2, 3, 5]
//   Step 4: Index 0 has no parent, done!
//
// Takes: the heap array, index of the newly inserted item
private do heap_bubble_up(&heap [HeapItem], &index int) {
    // Keep going until we reach the root (index 0) or find correct position
    for j in range(0, 1) {
        temp parentIndex = heap_parent_index(index)

        // If current item's priority is LESS than parent's, swap them
        // (In a min-heap, smaller priorities bubble up to the top)
        if heap[index].priority < heap[parentIndex].priority {
            // Swap current with parent
            temp tmp = heap[index]
            heap[index] = heap[parentIndex]
            heap[parentIndex] = tmp

            // Move up to parent's position and continue checking
            index = parentIndex
        } otherwise {
            // Parent is smaller or equal, heap property satisfied, we're done
            break
        }
    }
}

// BUBBLE DOWN: After removing root, move the replacement DOWN until heap property is restored
//
// Example: Pop from heap [1, 2, 3, 5]
//   Step 1: Remove root (1), move last item (5) to root -> [5, 2, 3]
//   Step 2: Compare 5 with children (2, 3): smallest child is 2, 5 > 2, swap -> [2, 5, 3]
//   Step 3: Index 1 has no children, done!
//
// Takes: the heap array, index to start bubbling down from (usually 0 after pop)
private do heap_bubble_down(&heap [HeapItem], &index int) {
    temp size = len(heap)
    temp flag = true

    as_long_as flag == true {
        temp smallest = index
        temp left = heap_left_child_index(index)
        temp right = heap_right_child_index(index)

        // Check if left child exists and is smaller than current smallest
        if left < size && heap[left].priority < heap[smallest].priority {
            smallest = left
        }

        // Check if right child exists and is smaller than current smallest
        if right < size && heap[right].priority < heap[smallest].priority {
            smallest = right
        }

        // If smallest is not the current node, swap and continue
        if smallest != index {
            temp tmp = heap[index]
            heap[index] = heap[smallest]
            heap[smallest] = tmp
            index = smallest
        } otherwise {
            // Current node is smaller than both children, done
            break
        }
    }
}


//===============================
//USER FACING CORE MODULE FUCNTIONS
//===============================

//Pushe passed in string value onto the passed heap with given priority(p)
//Lower priority numbers come out first
//

do heap_push(&heap [HeapItem], p int, v Variant){
	temp item = make_new_heap_item(p, v)
    arrays.append(heap, item)
    heap_bubble_up(heap, len(heap) - 1)
}

// do heap_push_string(&heap [HeapItem], p int, value string) {
//     temp v = make_string_variant(value)
//     temp item = make_new_heap_item(p, v)
//     arrays.append(heap, item)
//     heap_bubble_up(heap, len(heap) - 1)
// }

// //Push passed in int value onto the passed in heap with given priority(P)
// do heap_push_int(&heap [HeapItem], p int, value int) {
//     temp v = make_int_variant(value)
//     temp item = make_new_heap_item(p, v)
//     arrays.append(heap, item)
//     heap_bubble_up(heap, len(heap) - 1)
// }

// //Push passed in float value onto the passed in heap with given priority(P)
// do heap_push_float(&heap [HeapItem], p int, value float) {
//     temp v = make_float_variant(value)
//     temp item = make_new_heap_item(priority, v)
//     arrays.append(heap, item)
//     heap_bubble_up(heap, len(heap) - 1)
// }

// //Push passed in bool value onto the passed in heap with given priority(P)
// do heap_push_bool(&heap [HeapItem], p int, value bool) {
//     temp v = make_bool_variant(value)
//     temp item = make_new_heap_item(p, v)
//     arrays.append(heap, item)
//     heap_bubble_up(heap, len(heap) - 1)
// }

//Pops the highest-priority (lowest number) item from the passed in heap
//Returns the HeapItem that was removed/popped
do heap_pop(&heap [HeapItem]) -> HeapItem {
    if len(heap) == 0 {
        return new(HeapItem)
    }

    // Save the root itme state
    temp result = heap[0]

    //Move last item to root
    temp last_index = len(heap) - 1
    heap[0] = heap[last_index]

    // Remove last item
    arrays.pop(heap)

    // Restore heap property by bubbling down
    if len(heap) > 0 {
        heap_bubble_down(heap, 0)
    }

    return result
}

//Peek at the highest-priority item in the passed in heap without removing it
//Returns the HeapItem at the root of the heap
do heap_peek(heap [HeapItem]) -> HeapItem {
    if len(heap) == 0 {
        return new(HeapItem)
    }

    return heap[0]
}

//Check if the passed in heap is empty
do heap_is_empty(heap [HeapItem]) -> bool {
	if len(heap) == 0 {
		return true
	}

    return false
}

//Get the number of items in the passed in heap
do heap_size(heap [HeapItem]) -> int {
    return len(heap)
}

// Get the priority of a HeapItem
do heap_get_priority(item HeapItem) -> int {
    return item.priority
}

// Check what type the HeapItem's value is
// Returns: 0 = string, 1 = int, 2 = float, 3 = bool, -1 = unknown
do heap_get_type(item HeapItem) -> (int, string) {
    if item.value.type[0] == 1 {
        return 0, "string"
    }
    if item.value.type[1] == 1 {
        return 1 , "int"
    }
    if item.value.type[2] == 1 {
        return 2 ,"float"
    }
    if item.value.type[3] == 1 {
        return 3 , "bool"
    }
    return -1, "unknown"
}

//===============================
// USER FACING HELPER FUNCTIONS
//===============================
do heap_item_is_string(item HeapItem) -> bool {
    return item.value.type[0] == 1
}

do heap_item_is_int(item HeapItem) -> bool {
    return item.value.type[1] == 1
}

do heap_item_is_float(item HeapItem) -> bool {
    return item.value.type[2] == 1
}

do heap_item_is_bool(item HeapItem) -> bool {
    return item.value.type[3] == 1
}

// Extract string value from HeapItem
do heap_get_string(item HeapItem) -> string {
    return item.value.stringValue
}

// Extract int value from HeapItem
do heap_get_int(item HeapItem) -> int {
    return item.value.intValue
}

// Extract float value from HeapItem
do heap_get_float(item HeapItem) -> float {
    return item.value.floatValue
}

// Extract bool value from HeapItem
do heap_get_bool(item HeapItem) -> bool {
    return item.value.boolValue
}

do main(){
	heap_push(Heap,1,heap_make_variant(1))
}