/*
* EZ-Modules: A collection of helpful modules for the EZ programming language
* Be aware these modules may one day be added into the EZ language stdlib and thus would be superseded by the stdlib version
*
* Module Name: heap
* Module Desc: A min-heap (priority queue) implementation. Always returns the lowest priority item first.
* Functions are accessed via the module name (e.g., heap.push, heap.pop)
*
* File Name: heap.ez
* File Desc: Core heap data structure with push, pop, peek operations
*
* Author: Marshall A Burns
* GitHub: @SchoolyB
* Repo: https://github.com/SchoolyB/EZ-Modules
*
* Copyright (c) 2026 Marshall Burns
* Licensed under the MIT License
*/
module heap
import @arrays, @std

temp Heap [HeapItem]

const HeapItem struct {
	priority int
	value Variant
}

const Variant struct {
	stringValue string
	intValue int
	floatValue float
	boolValue bool
	type [int]
}

//===============================
// INTERNAL USE ONLY FUNCTIONS
//===============================

private do make_variant(strVal string = "", intVal int = 0, floatVal float = 0.0, boolVal bool = false, typeFlag [int] = {0, 0, 0, 0}) -> Variant {
	temp v = new(Variant)
	v.stringValue = strVal
	v.intValue = intVal
	v.floatValue = floatVal
	v.boolValue = boolVal
	v.type = typeFlag
	return v
}

//Creates a new HeapItem with passed in priority(p) and Variant(v)
private do make_new_heap_item(p int, v Variant) -> HeapItem {
	temp item = new(HeapItem)

	item.priority = p
	item.value = v
	return copy(item)
}

// Gets the parent index of a node at passed in index
private do parent_index(index int) -> int {
    return (index - 1) / 2
}

//Get the left child index of a node at index i
private do left_child_index(index int) -> int {
    return (2 * index) + 1
}

// Gets the right child index of a node at index i
private do right_child_index(index int) -> int {
    return (2 * index) + 2
}

// NOTE: Bubble up and down functions are all Claude Code... Not ashamed to say it - Marshall

// BUBBLE UP: After inserting at the end of the heap, move the item UP until heap property is restored
//
// Example: Insert priority 1 into heap [2, 5, 3]
//   Step 1: Add to end -> [2, 5, 3, 1]
//   Step 2: Compare 1 with parent (5 at index 1): 1 < 5, so swap -> [2, 1, 3, 5]
//   Step 3: Compare 1 with parent (2 at index 0): 1 < 2, so swap -> [1, 2, 3, 5]
//   Step 4: Index 0 has no parent, done!
//
// Takes: the heap array, index of the newly inserted item
private do bubble_up(&heap [HeapItem], &index int) {
    // Keep going until we reach the root (index 0) or find correct position
    for j in range(0, 1) {
        temp parentIndex = parent_index(index)

        // If current item's priority is LESS than parent's, swap them
        // (In a min-heap, smaller priorities bubble up to the top)
        if heap[index].priority < heap[parentIndex].priority {
            // Swap current with parent
            temp tmp = heap[index]
            heap[index] = heap[parentIndex]
            heap[parentIndex] = tmp

            // Move up to parent's position and continue checking
            index = parentIndex
        } otherwise {
            // Parent is smaller or equal, heap property satisfied, we're done
            break
        }
    }
}

// BUBBLE DOWN: After removing root, move the replacement DOWN until heap property is restored
//
// Example: Pop from heap [1, 2, 3, 5]
//   Step 1: Remove root (1), move last item (5) to root -> [5, 2, 3]
//   Step 2: Compare 5 with children (2, 3): smallest child is 2, 5 > 2, swap -> [2, 5, 3]
//   Step 3: Index 1 has no children, done!
//
// Takes: the heap array, index to start bubbling down from (usually 0 after pop)
private do bubble_down(&heap [HeapItem], &index int) {
    temp size = len(heap)
    temp flag = true

    as_long_as flag == true {
        temp smallest = index
        temp left = left_child_index(index)
        temp right = right_child_index(index)

        // Check if left child exists and is smaller than current smallest
        if left < size && heap[left].priority < heap[smallest].priority {
            smallest = left
        }

        // Check if right child exists and is smaller than current smallest
        if right < size && heap[right].priority < heap[smallest].priority {
            smallest = right
        }

        // If smallest is not the current node, swap and continue
        if smallest != index {
            temp tmp = heap[index]
            heap[index] = heap[smallest]
            heap[smallest] = tmp
            index = smallest
        } otherwise {
            // Current node is smaller than both children, done
            break
        }
    }
}


//===============================
// USER FACING CORE MODULE FUNCTIONS
//===============================

//Push a string value onto the heap with given priority (lower priority = comes out first)
do push_string(&heap [HeapItem], p int, value string) {
	temp v = make_variant(strVal: value, typeFlag: {1, 0, 0, 0})
	temp item = make_new_heap_item(p, v)
	arrays.append(heap, item)
	bubble_up(heap, len(heap) - 1)
}

//Push an int value onto the heap with given priority
do push_int(&heap [HeapItem], p int, value int) {
	temp v = make_variant(intVal: value, typeFlag: {0, 1, 0, 0})
	temp item = make_new_heap_item(p, v)
	arrays.append(heap, item)
	bubble_up(heap, len(heap) - 1)
}

//Push a float value onto the heap with given priority
do push_float(&heap [HeapItem], p int, value float) {
	temp v = make_variant(floatVal: value, typeFlag: {0, 0, 1, 0})
	temp item = make_new_heap_item(p, v)
	arrays.append(heap, item)
	bubble_up(heap, len(heap) - 1)
}

//Push a bool value onto the heap with given priority
do push_bool(&heap [HeapItem], p int, value bool) {
	temp v = make_variant(boolVal: value, typeFlag: {0, 0, 0, 1})
	temp item = make_new_heap_item(p, v)
	arrays.append(heap, item)
	bubble_up(heap, len(heap) - 1)
}

//Pops the highest-priority (lowest number) item from the passed in heap
//Returns the HeapItem that was removed/popped
do pop(&heap [HeapItem]) -> HeapItem {
    if len(heap) == 0 {
        return new(HeapItem)
    }

    // Save the root itme state
    temp result = heap[0]

    //Move last item to root
    temp last_index = len(heap) - 1
    heap[0] = heap[last_index]

    // Remove last item
    arrays.pop(heap)

    // Restore heap property by bubbling down
    if len(heap) > 0 {
        bubble_down(heap, 0)
    }

    return result
}

//Peek at the highest-priority item in the passed in heap without removing it
//Returns the HeapItem at the root of the heap
do peek(heap [HeapItem]) -> HeapItem {
    if len(heap) == 0 {
        return new(HeapItem)
    }

    return heap[0]
}

//Check if the passed in heap is empty
do is_empty(heap [HeapItem]) -> bool {
	if len(heap) == 0 {
		return true
	}

    return false
}

//Get the number of items in the passed in heap
do size(heap [HeapItem]) -> int {
    return len(heap)
}

// Get the priority of a HeapItem
do get_priority(item HeapItem) -> int {
    return item.priority
}

// Check what type the HeapItem's value is
// Returns: 0 = string, 1 = int, 2 = float, 3 = bool, -1 = unknown
do get_type(item HeapItem) -> (int, string) {
    if item.value.type[0] == 1 {
        return 0, "string"
    }
    if item.value.type[1] == 1 {
        return 1 , "int"
    }
    if item.value.type[2] == 1 {
        return 2 ,"float"
    }
    if item.value.type[3] == 1 {
        return 3 , "bool"
    }
    return -1, "unknown"
}

//===============================
// USER FACING HELPER FUNCTIONS
//===============================
do item_is_string(item HeapItem) -> bool {
    return item.value.type[0] == 1
}

do item_is_int(item HeapItem) -> bool {
    return item.value.type[1] == 1
}

do item_is_float(item HeapItem) -> bool {
    return item.value.type[2] == 1
}

do item_is_bool(item HeapItem) -> bool {
    return item.value.type[3] == 1
}

// Extract string value from HeapItem
do get_string(item HeapItem) -> string {
    return item.value.stringValue
}

// Extract int value from HeapItem
do get_int(item HeapItem) -> int {
    return item.value.intValue
}

// Extract float value from HeapItem
do get_float(item HeapItem) -> float {
    return item.value.floatValue
}

// Extract bool value from HeapItem
do get_bool(item HeapItem) -> bool {
    return item.value.boolValue
}

do main() {
	push_string(Heap, 1, "test")
}