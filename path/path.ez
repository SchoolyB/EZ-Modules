/*
* EZ-Modules: A collection of helpful modules for the EZ programming language
* Be aware these modules may one day be added into the EZ language stdlib and thus would be superseded by the stdlib version
*
* Module Name: path
* Module Desc: Cross-platform file path manipulation utilities
* Functions are accessed via the module name (e.g., path.join)
*
* File Name: path.ez
* File Desc: Path operations including join, get_base_name, separator, and more
*
* Author: Marshall A Burns
* GitHub: @SchoolyB
* Repo: https://github.com/SchoolyB/EZ-Modules
*
* Copyright (c) 2026 Marshall Burns
* Licensed under the MIT License
*/

module path

import @strings, @os, @io, @std, @arrays

const PathInfo struct {
    dir string
    base string
    name string
    ext string
}

//Returns the OS specific path separator
do separator() -> string {
    if os.CURRENT_OS == os.LINUX || os.CURRENT_OS == os.MAC_OS {
        return "/"
    }
    return "\\"
}

//Returns the OS specific path list delimiter
do delimiter() -> string {
    if os.CURRENT_OS == os.LINUX || os.CURRENT_OS == os.MAC_OS {
        return ":"
    }
    return ";"
}

//Joins each passed in string array values to create a valid file path based on OS
do join(arr [string]) -> string {
    return strings.join(arr, separator())
}

//Extracts the base name from the passed in path(p) and returns it
do get_base_name(p string) -> string {
    temp arr [string] = strings.split(p, separator())
    return arr[len(arr) - 1]
}

//Extracts the directory name from the passed in path(p) and returns it
do get_dir_name(p string) -> string {
    temp sep string = separator()
    temp arr [string] = strings.split(p, sep)

    if len(arr) <= 1 {
        return ""
    }

    temp dir_parts [string] = arrays.slice(arr, 0, len(arr) - 1)
    return strings.join(dir_parts, sep)
}

//Returns the file extension including the dot (e.g., ".txt")
//Returns empty string if no extension found
do get_extension(p string) -> string {
    temp base string = get_base_name(p)

    temp last_dot int = -1
    temp i int = len(base) - 1
    as_long_as i >= 0 {
        if strings.char_at(base, i) == "." {
            last_dot = i
            break
        }
        i = i - 1
    }

    if last_dot == -1 || last_dot == 0 {
        return ""
    }

    return strings.substring(base, last_dot, len(base))
}

//Checks if the passed in path(p) is absolute
do is_absolute(p string) -> bool {
    if len(p) == 0 {
        return false
    }

    if os.CURRENT_OS == os.LINUX || os.CURRENT_OS == os.MAC_OS {
        return strings.starts_with(p, "/")
    }

    //Windows: check for drive letter (C:\) or (\\)
    if len(p) >= 3 {
        temp second_char string = strings.char_at(p, 1)
        temp third_char string = strings.char_at(p, 2)
        if second_char == ":" && third_char == "\\" {
            return true
        }
    }
    if len(p) >= 2 {
        if strings.starts_with(p, "\\\\") {
            return true
        }
    }

    return false
}

//Removes the extension from the path(p)
do strip_extension(p string) -> string {
    temp ext string = get_extension(p)

    if ext == "" {
        return p
    }

    return strings.substring(p, 0, len(p) - len(ext))
}

//Checks if the path(p) has the passed extension(ext)
do has_extension(p string, &ext string) -> bool {
    temp currentExtension string = get_extension(p)

    if len(ext) > 0 && !strings.starts_with(ext, ".") {
        ext = ".${ext}"
    }

    return strings.lower(currentExtension) == strings.lower(ext)
}

//Changes the extension of the path to newExtension
do change_extension(p string, &newExtension string) -> string {
    temp base string = strip_extension(p)

    if len(newExtension) > 0 && !strings.starts_with(newExtension, ".") {
        newExtension = ".${newExtension}"
    }

    return base + newExtension
}

//Splits the path into directory and base name
do split(p string) -> (string, string) {
    return get_dir_name(p), get_base_name(p)
}

//Parses a path into its components and returns a PathInfo struct
do parse(p string) -> PathInfo {
    temp info = new(PathInfo)
    info.dir = get_dir_name(p)
    info.base = get_base_name(p)
    info.ext = get_extension(p)
    info.name = strip_extension(info.base)
    return info
}